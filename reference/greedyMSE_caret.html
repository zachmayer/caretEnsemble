<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>caret interface for greedyMSE — greedyMSE_caret • caretEnsemble</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="caret interface for greedyMSE — greedyMSE_caret"><meta name="description" content="caret interface for greedyMSE. greedyMSE works
well when you want an ensemble that will never be worse than any single predictor
in the dataset. It does not use an intercept and it does not allow for
negative coefficients. This makes it highly constrained and in general
does not work well on standard classification and regression problems.
However, it does work well in the case of:
* The predictors are highly correlated with each other
* The predictors are highly correlated with the model
* You expect or want positive only coefficients
In the worse case, this method will select one input and use that,
but in many other cases it will return a positive, weighted average
of the inputs. Since it never uses negative weights, you never get
into a scenario where one model is weighted negative and on new data
you get were predictions because a correlation changed.
Since this model will always be a positive weighted average of the inputs,
it will rarely do worse than the individual models on new data."><meta property="og:description" content="caret interface for greedyMSE. greedyMSE works
well when you want an ensemble that will never be worse than any single predictor
in the dataset. It does not use an intercept and it does not allow for
negative coefficients. This makes it highly constrained and in general
does not work well on standard classification and regression problems.
However, it does work well in the case of:
* The predictors are highly correlated with each other
* The predictors are highly correlated with the model
* You expect or want positive only coefficients
In the worse case, this method will select one input and use that,
but in many other cases it will return a positive, weighted average
of the inputs. Since it never uses negative weights, you never get
into a scenario where one model is weighted negative and on new data
you get were predictions because a correlation changed.
Since this model will always be a positive weighted average of the inputs,
it will rarely do worse than the individual models on new data."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">caretEnsemble</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">4.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/caretEnsemble-intro.html">A Brief Introduction to caretEnsemble</a></li>
    <li><a class="dropdown-item" href="../articles/Version-4.0-New-Features.html">Version-4.0-New-Features</a></li>
  </ul></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/zachmayer/caretEnsemble/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>caret interface for greedyMSE</h1>
      <small class="dont-index">Source: <a href="https://github.com/zachmayer/caretEnsemble/blob/main/R/greedyOpt.R" class="external-link"><code>R/greedyOpt.R</code></a></small>
      <div class="d-none name"><code>greedyMSE_caret.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>caret interface for greedyMSE. greedyMSE works
well when you want an ensemble that will never be worse than any single predictor
in the dataset. It does not use an intercept and it does not allow for
negative coefficients. This makes it highly constrained and in general
does not work well on standard classification and regression problems.
However, it does work well in the case of:
* The predictors are highly correlated with each other
* The predictors are highly correlated with the model
* You expect or want positive only coefficients
In the worse case, this method will select one input and use that,
but in many other cases it will return a positive, weighted average
of the inputs. Since it never uses negative weights, you never get
into a scenario where one model is weighted negative and on new data
you get were predictions because a correlation changed.
Since this model will always be a positive weighted average of the inputs,
it will rarely do worse than the individual models on new data.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">greedyMSE_caret</span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
    </div>


  </main></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Zachary A. Deane-Mayer.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.0.</p>
</div>

    </footer></div>





  </body></html>

