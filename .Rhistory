devtools::load_all()
devtools::document()
devtools::test()
install.packages("earth")
devtools::test()
devtools::load_all()
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart", "glm")
)
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart")
)
stack_model <- caretStack(models_list, method = "glmnet")
attr(stack_model, "original_features") <- colnames(iris)[1:4]
test_that("plot_variable_importance basic functionality", {
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
expect_true(inherits(p, c("patchwork", "gg")))
})
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
p
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart")
)
stack_model <- caretStack(models_list, method = "glmnet")
attr(stack_model, "original_features") <- colnames(iris)[1:4]
test_that("plot_variable_importance basic functionality", {
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
expect_true(inherits(p, c("patchwork", "gg")))
})
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
p
attr(stack_model, "original_features") <- colnames(iris)[1:4]
stack_model
attr(stack_model)
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart")
)
stack_model <- caretStack(models_list, method = "glmnet",original_features = colnames(X.class))
test_that("plot_variable_importance basic functionality", {
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
expect_true(inherits(p, c("patchwork", "gg")))
})
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart")
)
stack_model <- caretStack(models_list, method = "glmnet",original_features = colnames(iris[, 1:4]),new_X = iris[, 1:4],new_y =iris$Species )
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4])
p
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4],stat_type = "max")
p
data(iris)
set.seed(107L)
inTrain <- caret::createDataPartition(y = iris$Species, p = 0.75, list = FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
# Cross validation with bootstrapping (5 folds)
trControl <- caret::trainControl(
method = "boot",
number = 5L,
classProbs = TRUE,
savePredictions = "final",
index = caret::createResample(training$Species, 5),
)
# Build a ensemble with 5 models
model_list <- caretList(
x=training[,-5],
y=training$Species,
trControl = trControl,
methodList = c("rpart"),
tuneList = list(
rf1 = caretModelSpec(method = "rf", tuneGrid = data.frame(.mtry = 2)),
# rf2 = caretModelSpec(method = "rf", tuneGrid = data.frame(.mtry = 10), preProcess = "pca"),
nn = caretModelSpec(method = "nnet", tuneLength = 2, trace = FALSE)
)
)
# Train the stack with another random forest
stack_model_rf <- caretStack(model_list, method = "rf",original_features=colnames(training[,-5]),new_X = training[,-5],new_y = training$Species)
plot_variable_importance(stack_model_rf,newdata=training[,-5],stat_type = "max")
devtools::load_all()
devtools::load_all()
# Ejemplo de creación simple del stack_model
models_list <- caretList(
x = iris[, 1:4],
y = iris$Species,
trControl = trainControl(method = "cv"),
methodList = c("rpart")
)
stack_model <- caretStack(models_list, method = "glmnet",original_features = colnames(iris[, 1:4]),new_X = iris[, 1:4],new_y =iris$Species )
p <- plot_variable_importance(stack_model, newdata = iris[, 1:4],stat_type = "max")
p
data(iris)
set.seed(107L)
inTrain <- caret::createDataPartition(y = iris$Species, p = 0.75, list = FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
# Cross validation with bootstrapping (5 folds)
trControl <- caret::trainControl(
method = "boot",
number = 5L,
classProbs = TRUE,
savePredictions = "final",
index = caret::createResample(training$Species, 5),
)
# Build a ensemble with 5 models
model_list <- caretList(
x=training[,-5],
y=training$Species,
trControl = trControl,
methodList = c("rpart"),
tuneList = list(
rf1 = caretModelSpec(method = "rf", tuneGrid = data.frame(.mtry = 2)),
# rf2 = caretModelSpec(method = "rf", tuneGrid = data.frame(.mtry = 10), preProcess = "pca"),
nn = caretModelSpec(method = "nnet", tuneLength = 2, trace = FALSE)
)
)
# Train the stack with another random forest
stack_model_rf <- caretStack(model_list, method = "rf",original_features=colnames(training[,-5]),new_X = training[,-5],new_y = training$Species)
plot_variable_importance(stack_model_rf,newdata=training[,-5],stat_type = "max")
plot_variable_importance(stack_model_rf,newdata=training[,-5],stat_type = "mean")
plot_variable_importance(stack_model_rf,newdata=training[,-5],stat_type = "sum")
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
devtools::test()
# Ajusta esta ruta a tu carpeta en WSL
base_dir <- "/mnt/c/Users/balle/Downloads/NORMALES/DIMENSION_2/WITHOUT_MISLABELLED"
n <- "n_1000"
# Detectar todas las carpetas t_*
t_dirs <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
t_dirs <- t_dirs[grepl("t_", basename(t_dirs))]
for (t_dir in t_dirs) {
t_name <- basename(t_dir)
resultados_dir <- file.path(t_dir, n, "RESULTADOS")
if (!dir.exists(resultados_dir)) next
# Detectar todas las carpetas de runs
run_dirs <- list.dirs(resultados_dir, full.names = TRUE, recursive = FALSE)
# Leer todos los accuracy.csv y combinarlos
accuracy_list <- lapply(run_dirs, function(run_dir) {
file <- file.path(run_dir, "accuracy.csv")
if (file.exists(file)) {
read.csv(file, header = TRUE)
} else {
NULL
}
})
accuracy_list <- Filter(Negate(is.null), accuracy_list)
if (length(accuracy_list) == 0) next
# Crear matriz con todas las ejecuciones
accuracy_mat <- do.call(rbind, accuracy_list)
accuracy_mat <- apply(accuracy_mat, 2, as.numeric)
# Calcular media y desviación estándar por columna
media <- colMeans(accuracy_mat, na.rm = TRUE)
desv  <- apply(accuracy_mat, 2, sd, na.rm = TRUE)
# Crear tabla resumen tipo "media (desv)"
tabla_resumen <- data.frame(t(sapply(seq_along(media), function(i) {
sprintf('%.4f (%.4f)', media[i], desv[i])
})))
colnames(tabla_resumen) <- colnames(accuracy_mat)
# Guardar tabla_resumen.csv en la carpeta n_1000
write.csv(
tabla_resumen,
file.path(t_dir, n, "tabla_resumen.csv"),
row.names = FALSE
)
cat("✅ Generado tabla_resumen.csv para", t_name, "\n")
}
# Detectar todas las carpetas t_*
t_dirs <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
t_dirs
base_dir <- "/mnt/c/Users/balle/Downloads/NORMALES/DIMENSION_2/WITHOUT_MISLABELLED"
list.files(base_dir)
# Ajusta esta ruta a tu carpeta en WSL
base_dir <- "C:Users/balle/Downloads/NORMALES/DIMENSION_2/WITHOUT_MISLABELLED"
n <- "n_1000"
list.files(base_dir)
# Ajusta esta ruta a tu carpeta en WSL
base_dir <- "C:Users/balle/Downloads/NORMALES/DIMENSION_2/WITHOUT_MISLABELLED"
n <- "n_1000"
list.files(base_dir)
# Detectar todas las carpetas t_*
t_dirs <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
t_dirs
t_dirs <- t_dirs[grepl("t_", basename(t_dirs))]
t_dirs
for (t_dir in t_dirs) {
t_name <- basename(t_dir)
resultados_dir <- file.path(t_dir, n, "RESULTADOS")
if (!dir.exists(resultados_dir)) next
# Detectar todas las carpetas de runs
run_dirs <- list.dirs(resultados_dir, full.names = TRUE, recursive = FALSE)
# Leer todos los accuracy.csv y combinarlos
accuracy_list <- lapply(run_dirs, function(run_dir) {
file <- file.path(run_dir, "accuracy.csv")
if (file.exists(file)) {
read.csv(file, header = TRUE)
} else {
NULL
}
})
accuracy_list <- Filter(Negate(is.null), accuracy_list)
if (length(accuracy_list) == 0) next
# Crear matriz con todas las ejecuciones
accuracy_mat <- do.call(rbind, accuracy_list)
accuracy_mat <- apply(accuracy_mat, 2, as.numeric)
# Calcular media y desviación estándar por columna
media <- colMeans(accuracy_mat, na.rm = TRUE)
desv  <- apply(accuracy_mat, 2, sd, na.rm = TRUE)
# Crear tabla resumen tipo "media (desv)"
tabla_resumen <- data.frame(t(sapply(seq_along(media), function(i) {
sprintf('%.4f (%.4f)', media[i], desv[i])
})))
colnames(tabla_resumen) <- colnames(accuracy_mat)
# Guardar tabla_resumen.csv en la carpeta n_1000
write.csv(
tabla_resumen,
file.path(t_dir, n, "tabla_resumen.csv"),
row.names = FALSE
)
cat("✅ Generado tabla_resumen.csv para", t_name, "\n")
}
# Ajusta esta ruta a tu carpeta en WSL
base_dir <- "C:Users/balle/Downloads/NORMALES/DIMENSION_2/WITH_MISLABELLED/MSTRClass_vs_knn"
n <- "n_1000"
list.files(base_dir)
# Detectar todas las carpetas t_*
t_dirs <- list.dirs(base_dir, full.names = TRUE, recursive = FALSE)
t_dirs <- t_dirs[grepl("t_", basename(t_dirs))]
t_dirs
for (t_dir in t_dirs) {
t_name <- basename(t_dir)
resultados_dir <- file.path(t_dir, n, "RESULTADOS")
if (!dir.exists(resultados_dir)) next
# Detectar todas las carpetas de runs
run_dirs <- list.dirs(resultados_dir, full.names = TRUE, recursive = FALSE)
# Leer todos los accuracy.csv y combinarlos
accuracy_list <- lapply(run_dirs, function(run_dir) {
file <- file.path(run_dir, "accuracy.csv")
if (file.exists(file)) {
read.csv(file, header = TRUE)
} else {
NULL
}
})
accuracy_list <- Filter(Negate(is.null), accuracy_list)
if (length(accuracy_list) == 0) next
# Crear matriz con todas las ejecuciones
accuracy_mat <- do.call(rbind, accuracy_list)
accuracy_mat <- apply(accuracy_mat, 2, as.numeric)
# Calcular media y desviación estándar por columna
media <- colMeans(accuracy_mat, na.rm = TRUE)
desv  <- apply(accuracy_mat, 2, sd, na.rm = TRUE)
# Crear tabla resumen tipo "media (desv)"
tabla_resumen <- data.frame(t(sapply(seq_along(media), function(i) {
sprintf('%.4f (%.4f)', media[i], desv[i])
})))
colnames(tabla_resumen) <- colnames(accuracy_mat)
# Guardar tabla_resumen.csv en la carpeta n_1000
write.csv(
tabla_resumen,
file.path(t_dir, n, "tabla_resumen.csv"),
row.names = FALSE
)
cat("✅ Generado tabla_resumen.csv para", t_name, "\n")
}
devtools::document()
devtools::check(error_on = "note")
devtools::check(error_on = "note")
